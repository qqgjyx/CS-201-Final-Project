Index: src/DatabaseProcessing.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\nPeopleRecord Class: Comparable Interface\nYour PeopleRecord class has a compareTo method, but it does not implement the Comparable interface. To adhere to Java's conventions and ensure compatibility with collections that rely on comparison (like a sorted tree or heap), it's recommended to explicitly implement Comparable<PeopleRecord>.\n\nMyBST Class: Handling Duplicates\nYour current MyBST implementation does not account for the possibility of duplicate entries. Since you're comparing records by family name, consider what should happen if two records have the same family name. You might need to define a secondary comparison criterion or handle duplicates in some other manner.\n\nMyHeap Class: Comparison Logic\nEnsure that the comparison logic in your MyHeap class aligns with how you want to structure the heap (min-heap or max-heap). The current implementation seems to be for a min-heap. If a max-heap is desired, you'll need to adjust the comparison logic in heapifyUp and heapifyDown.\nUnder the codes have already realized the function of smallest heap. If the larget heap is needed, you can change the \"smallest\" in line 289 into \"largest\".\n\nMyHashmap Class: Resize Logic and Deleted Entries\nYour MyHashmap does not currently handle resizing when it becomes full, nor does it have a mechanism to handle deleted entries (like using a special object to mark deleted slots). Depending on the expected use case and data size, you might want to implement these features.\nAdditionally, ensure that the hash function (getHashIndex) evenly distributes entries to minimize collisions.\n\nGeneral:\nError Handling\nTODO:Consider adding error handling, particularly for edge cases. For example, what should happen if a null PeopleRecord is inserted into the BST or Heap? Should your Hashmap throw an exception when it's full, or should it resize?\n\nTesting and Validation\nTODO:Thoroughly test each class to ensure they behave as expected, particularly under edge cases (like inserting duplicate values into the BST or handling collisions in the Hashmap).\n\nDatabaseProcessing Class\nTODO:The DatabaseProcessing class is currently empty. This class should eventually include the logic for interacting with these data structures and implementing the required functionalities like loading data, searching, sorting, etc.\n */\n\nimport java.util.*;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.util.stream.Collectors;\n\npublic class DatabaseProcessing {\n    private MyBST bst;\n    private MyHeap heap;\n    private MyHashmap hashmap;\n\n    public DatabaseProcessing() {\n        bst = new MyBST();\n        heap = new MyHeap();\n        hashmap = new MyHashmap(100); // Assuming an initial capacity of 100\n    }\n\n    // Method a: loadData\n    public void loadData(String fileName) throws FileNotFoundException {\n        File file = new File(fileName);\n        Scanner scanner = new Scanner(file);\n\n        while (scanner.hasNextLine()) {\n            String line = scanner.nextLine();\n            String[] data = line.split(\";\");\n            PeopleRecord record = new PeopleRecord(\n                    data[0], data[1], data[2], data[3], data[4], data[5],\n                    data[6], data[7], data[8], data[9], data[10], data[11], data[12]\n            );\n            bst.insert(record);\n        }\n        scanner.close();\n    }\n\n    // Method b: search\n    public List<PeopleRecord> search(String givenName, String familyName) {\n        return bst.search(givenName, familyName);\n    }\n\n    // Method c: sort\n    public List<PeopleRecord> sort() {\n        List<PeopleRecord> sortedList = new ArrayList<>();\n        transferBSTtoHeap(bst.root);\n        while (heap.size() > 0) {\n            sortedList.add(heap.remove());\n        }\n        return sortedList;\n    }\n\n    private void transferBSTtoHeap(PeopleRecord node) {\n        if (node != null) {\n            heap.insert(node);\n            transferBSTtoHeap(node.left);\n            transferBSTtoHeap(node.right);\n        }\n    }\n\n    // Method d: getMostFrequentWords\n    public Map<String, Integer> getMostFrequentWords(String fileName, int count, int len) throws FileNotFoundException, ShortLengthException {\n        if (len < 3) {\n            throw new ShortLengthException(\"Length is less than 3\");\n        }\n\n        Scanner scanner = new Scanner(new File(fileName));\n        Map<String, Integer> wordFrequencyMap = new HashMap<>();\n\n        while (scanner.hasNext()) {\n            String line = scanner.nextLine();\n            String[] words = line.split(\";\");\n\n            for (String word : words) {\n                word = word.replaceAll(\"[^a-zA-Z]\", \"\");\n                if (word.length() >= len) {\n                    wordFrequencyMap.put(word, wordFrequencyMap.getOrDefault(word, 0) + 1);\n                }\n            }\n        }\n        scanner.close();\n\n        // Create a list from elements of the hashmap\n        List<Map.Entry<String, Integer>> list = new ArrayList<>(wordFrequencyMap.entrySet());\n\n        // Sort the list using lambda expression\n        list.sort((o1, o2) -> o2.getValue().compareTo(o1.getValue()));\n\n        // Put the sorted data back into the hashmap\n        LinkedHashMap<String, Integer> sortedMap = new LinkedHashMap<>();\n        for (Map.Entry<String, Integer> entry : list) {\n            sortedMap.put(entry.getKey(), entry.getValue());\n        }\n\n        // Return only the top 'count' elements\n        return sortedMap.entrySet().stream()\n                .limit(count)\n                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue, (e1, e2) -> e1, LinkedHashMap::new));\n    }\n\n    // Custom exception class\n    class ShortLengthException extends Exception {\n        public ShortLengthException(String message) {\n            super(message);\n        }\n    }\n\n    // Main method for testing\n    public static void main(String[] args) {\n        DatabaseProcessing dbProcessing = new DatabaseProcessing();\n        try {\n            dbProcessing.loadData(\"resources/people.txt\");\n\n            // Test search\n            List<PeopleRecord> searchResults = dbProcessing.search(\"Johnetta\", \"Abdallah\");\n            System.out.println(\"Search Results: \" + searchResults);\n\n            // Test sort\n            List<PeopleRecord> sortedRecords = dbProcessing.sort();\n//            System.out.println(\"Sorted Records: \" + sortedRecords);\n\n            // Test getMostFrequentWords\n            Map<String, Integer> frequentWords = dbProcessing.getMostFrequentWords(\"resources/people.txt\", 5, 3);\n            System.out.println(\"Frequent Words: \" + frequentWords);\n\n        } catch (FileNotFoundException e) {\n            System.err.println(\"File not found: \" + e.getMessage());\n        } catch (ShortLengthException e) {\n            System.err.println(\"Short length exception: \" + e.getMessage());\n        }\n    }\n}\n\n\nclass   MyBST {\n    PeopleRecord root; // Root node of the BST\n\n    // Constructor\n    public MyBST() {\n        this.root = null;\n    }\n\n    // Method to get information about the tree (total nodes and height)\n    public String getInfo() {\n        int totalNodes = countNodes(root);\n        int height = treeHeight(root);\n        return \"Total nodes: \" + totalNodes + \", Height of tree: \" + height;\n    }\n\n    // Helper method to count nodes\n    private int countNodes(PeopleRecord node) {\n        if (node == null) {\n            return 0;\n        }\n        return 1 + countNodes(node.left) + countNodes(node.right);\n    }\n\n    // Helper method to determine the height of the tree\n    private int treeHeight(PeopleRecord node) {\n        if (node == null) {\n            return 0;\n        }\n        return 1 + Math.max(treeHeight(node.left), treeHeight(node.right));\n    }\n\n    // Method to insert a new PeopleRecord into the tree\n    public void insert(PeopleRecord newRecord) {\n        if (newRecord == null) {\n            throw new NullPointerException(\"Cannot insert null PeopleRecord.\");\n        }\n        root = insertRecord(root, newRecord);\n    }\n\n    // Recursive helper method for insertion\n    private PeopleRecord insertRecord(PeopleRecord current, PeopleRecord newRecord) {\n        if (current == null) {\n            return newRecord;\n        }\n\n        if (newRecord.compareTo(current) == 0) {\n            System.out.println(\"Duplicate record found. Ignoring the new record.\");\n            return current;\n        }\n\n        if (newRecord.compareTo(current) < 0) {\n            current.left = insertRecord(current.left, newRecord);\n        } else if (newRecord.compareTo(current) > 0) {\n            current.right = insertRecord(current.right, newRecord);\n        }\n        return current; // Return the (unchanged) node pointer\n    }\n\n    // Method to search for records by first/given name and family name\n    public List<PeopleRecord> search(String givenName, String familyName) {\n        List<PeopleRecord> matchingRecords = new ArrayList<>();\n        searchRecords(root, givenName, familyName, matchingRecords);\n        return matchingRecords;\n    }\n\n    // Recursive helper method for search\n    private void searchRecords(PeopleRecord node, String givenName,\n                               String familyName, List<PeopleRecord> matchingRecords) {\n        if (node != null) {\n            if (node.getGivenName().equals(givenName) && node.getFamilyName().equals(familyName)) {\n                matchingRecords.add(node);\n            }\n            // Assuming the tree is ordered by family name, we can decide which subtree to search\n            if (familyName.compareTo(node.getFamilyName()) < 0) {\n                searchRecords(node.left, givenName, familyName, matchingRecords);\n            } else {\n                searchRecords(node.right, givenName, familyName, matchingRecords);\n            }\n        }\n    }\n}\n\nclass MyHeap {\n    private List<PeopleRecord> heap;\n\n    // Constructor\n    public MyHeap() {\n        this.heap = new ArrayList<>();\n    }\n\n    // Method to add a new PeopleRecord into the heap\n    public void insert(PeopleRecord newRecord) {\n        heap.add(newRecord); // Add at the end of the list\n        heapifyUp(heap.size() - 1); // Adjust the heap from the last element upwards\n    }\n\n    // Helper method to maintain the heap property from bottom to top\n    private void heapifyUp(int index) {\n        int parentIndex = (index - 1) / 2;\n        if (index > 0 && heap.get(index).compareTo(heap.get(parentIndex)) < 0) {\n            // Swap if the current node is smaller than its parent\n            Collections.swap(heap, index, parentIndex);\n            // Heapify up from the parent's position\n            heapifyUp(parentIndex);\n        }\n    }\n\n    // Method to remove the root element (minimum element) from the heap\n    public PeopleRecord remove() {\n        if (heap.isEmpty()) {\n            return null; // Or throw an exception\n        }\n        PeopleRecord removedRecord = heap.get(0); // The root element\n        heap.set(0, heap.get(heap.size() - 1)); // Move the last element to the root\n        heap.remove(heap.size() - 1); // Remove the last element\n        heapifyDown(0); // Adjust the heap from the root downwards\n        return removedRecord;\n    }\n\n    // Method to get the size of the heap\n    public int size() {\n        return heap.size();\n    }\n\n    // Helper method to maintain the heap property from top to bottom\n    private void heapifyDown(int index) {\n        int smallest = index;\n        int leftChildIndex = 2 * index + 1;\n        int rightChildIndex = 2 * index + 2;\n\n        if (leftChildIndex < heap.size() && heap.get(leftChildIndex).compareTo(heap.get(smallest)) < 0) {\n            smallest = leftChildIndex;\n        }\n\n        if (rightChildIndex < heap.size() && heap.get(rightChildIndex).compareTo(heap.get(smallest)) < 0) {\n            smallest = rightChildIndex;\n        }\n\n        if (smallest != index) {\n            // Swap if a child node is smaller than the current node\n            Collections.swap(heap, index, smallest);\n            // Heapify down from the smallest child's position\n            heapifyDown(smallest);\n        }\n    }\n}\n\nclass MyHashmap {\n    private final PeopleRecord[] table;\n    private final int capacity;\n    private int size;\n\n    // Constructor\n    public MyHashmap(int capacity) {\n        this.capacity = capacity;\n        this.table = new PeopleRecord[capacity];\n        this.size = 0;\n    }\n\n    // Method to add a PeopleRecord to the hashmap\n    public void put(PeopleRecord record) {\n        int index = getHashIndex(record.getFamilyName());\n        int originalIndex = index;\n        int i = 1;\n\n        while (table[index] != null) {\n            index = (originalIndex + i * i) % capacity; // Quadratic probing\n            if (index == originalIndex) { // Table is full\n                return; // Or resize the table\n            }\n            i++;\n        }\n\n        table[index] = record;\n        size++;\n    }\n\n    // Method to get a PeopleRecord by key (e.g., family name)\n    public PeopleRecord get(String key) {\n        int index = getHashIndex(key);\n        int originalIndex = index;\n        int i = 1;\n\n        while (table[index] != null) {\n            if (table[index].getFamilyName().equals(key)) {\n                return table[index];\n            }\n            index = (originalIndex + i * i) % capacity; // Quadratic probing\n            if (index == originalIndex) {\n                break;\n            }\n            i++;\n        }\n\n        return null; // Not found\n    }\n\n    // Method to delete a PeopleRecord by key\n    public void delete(String key) {\n        int index = getHashIndex(key);\n        int originalIndex = index;\n        int i = 1;\n\n        while (table[index] != null) {\n            if (table[index].getFamilyName().equals(key)) {\n                table[index] = null; // Mark as deleted\n                size--;\n                return;\n            }\n            index = (originalIndex + i * i) % capacity; // Quadratic probing\n            if (index == originalIndex) {\n                break;\n            }\n            i++;\n        }\n    }\n\n    // Method to compute the hash index\n    private int getHashIndex(String key) {\n        return key.hashCode() % capacity;\n    }\n\n    // Method to check the number of records in the hashmap\n    public int size() {\n        return size;\n    }\n\n    // Additional methods as required...\n    static class Deleted extends PeopleRecord {\n        static final Deleted INSTANCE = new Deleted();\n\n        private Deleted() {\n            super(null, null, null, null, null, null, null, null, null, null, null, null, null);\n        }\n    }\n}\n\n\nclass PeopleRecord implements Comparable<PeopleRecord> {\n    // Attributes\n    private String givenName;\n    private String familyName;\n    private String companyName;\n    private String address;\n    private String city;\n    private String county;\n    private String state;\n    private String zip;\n    private String phone1;\n    private String phone2;\n    private String email;\n    private String web;\n    private String birthday;\n\n    // References to child nodes in the tree\n    PeopleRecord left;\n    PeopleRecord right;\n\n    // Constructor\n    public PeopleRecord(String givenName, String familyName, String companyName,\n                        String address, String city, String county, String state,\n                        String zip, String phone1, String phone2, String email,\n                        String web, String birthday) {\n        this.givenName = givenName;\n        this.familyName = familyName;\n        this.companyName = companyName;\n        this.address = address;\n        this.city = city;\n        this.county = county;\n        this.state = state;\n        this.zip = zip;\n        this.phone1 = phone1;\n        this.phone2 = phone2;\n        this.email = email;\n        this.web = web;\n        this.birthday = birthday;\n        this.left = null;\n        this.right = null;\n    }\n\n    // Getters and Setters\n    public String getGivenName() { return givenName; }\n    public void setGivenName(String givenName) { this.givenName = givenName; }\n\n    public String getFamilyName() { return familyName; }\n    public void setFamilyName(String familyName) { this.familyName = familyName; }\n\n    public String getCompanyName() { return companyName; }\n    public void setCompanyName(String companyName) { this.companyName = companyName; }\n\n    public String getAddress() { return address; }\n    public void setAddress(String address) { this.address = address; }\n\n    public String getCity() { return city; }\n    public void setCity(String city) { this.city = city; }\n\n    public String getCounty() { return county; }\n    public void setCounty(String county) { this.county = county; }\n\n    public String getState() { return state; }\n    public void setState(String state) { this.state = state; }\n\n    public String getZip() { return zip; }\n    public void setZip(String zip) { this.zip = zip; }\n\n    public String getPhone1() { return phone1; }\n    public void setPhone1(String phone1) { this.phone1 = phone1; }\n\n    public String getPhone2() { return phone2; }\n    public void setPhone2(String phone2) { this.phone2 = phone2; }\n\n    public String getEmail() { return email; }\n    public void setEmail(String email) { this.email = email; }\n\n    public String getWeb() { return web; }\n    public void setWeb(String web) { this.web = web; }\n\n    public String getBirthday() { return birthday; }\n    public void setBirthday(String birthday) { this.birthday = birthday; }\n\n    // toString Method\n    @Override\n    public String toString() {\n        return \"PeopleRecord{\" +\n                \"givenName='\" + givenName + '\\'' +\n                \", familyName='\" + familyName + '\\'' +\n                \", companyName='\" + companyName + '\\'' +\n                \", address='\" + address + '\\'' +\n                \", city='\" + city + '\\'' +\n                \", county='\" + county + '\\'' +\n                \", state='\" + state + '\\'' +\n                \", zip='\" + zip + '\\'' +\n                \", phone1='\" + phone1 + '\\'' +\n                \", phone2='\" + phone2 + '\\'' +\n                \", email='\" + email + '\\'' +\n                \", web='\" + web + '\\'' +\n                \", birthday='\" + birthday + '\\'' +\n                '}';\n    }\n\n    // compareTo Method\n    public int compareTo(PeopleRecord other) {\n        int lastNameComparison = this.familyName.compareTo(other.familyName);\n        if (lastNameComparison == 0) {\n            return this.givenName.compareTo(other.givenName);\n        }\n        return lastNameComparison;\n    }\n}\n\n\n\n\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/DatabaseProcessing.java b/src/DatabaseProcessing.java
--- a/src/DatabaseProcessing.java	(revision 913c7a88f881367f958969be0cd7f61701a1ca93)
+++ b/src/DatabaseProcessing.java	(date 1702101128988)
@@ -15,13 +15,13 @@
 
 General:
 Error Handling
-TODO:Consider adding error handling, particularly for edge cases. For example, what should happen if a null PeopleRecord is inserted into the BST or Heap? Should your Hashmap throw an exception when it's full, or should it resize?
+Consider adding error handling, particularly for edge cases. For example, what should happen if a null PeopleRecord is inserted into the BST or Heap? Should your Hashmap throw an exception when it's full, or should it resize?
 
 Testing and Validation
-TODO:Thoroughly test each class to ensure they behave as expected, particularly under edge cases (like inserting duplicate values into the BST or handling collisions in the Hashmap).
+Thoroughly test each class to ensure they behave as expected, particularly under edge cases (like inserting duplicate values into the BST or handling collisions in the Hashmap).
 
 DatabaseProcessing Class
-TODO:The DatabaseProcessing class is currently empty. This class should eventually include the logic for interacting with these data structures and implementing the required functionalities like loading data, searching, sorting, etc.
+The DatabaseProcessing class is currently empty. This class should eventually include the logic for interacting with these data structures and implementing the required functionalities like loading data, searching, sorting, etc.
  */
 
 import java.util.*;
@@ -154,7 +154,7 @@
 }
 
 
-class   MyBST {
+class MyBST {
     PeopleRecord root; // Root node of the BST
 
     // Constructor
Index: .idea/workspace.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project version=\"4\">\n  <component name=\"AutoImportSettings\">\n    <option name=\"autoReloadType\" value=\"SELECTIVE\" />\n  </component>\n  <component name=\"ChangeListManager\">\n    <list default=\"true\" id=\"be025498-9dd4-47fa-9e32-ac2e4e208a37\" name=\"Changes\" comment=\"v0.9.1 workable-not tested\">\n      <change beforePath=\"$PROJECT_DIR$/.idea/workspace.xml\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/.idea/workspace.xml\" afterDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/resources/DatabaseProcessing.java\" beforeDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/src/DatabaseProcessing.java\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/DatabaseProcessing.java\" afterDir=\"false\" />\n    </list>\n    <option name=\"SHOW_DIALOG\" value=\"false\" />\n    <option name=\"HIGHLIGHT_CONFLICTS\" value=\"true\" />\n    <option name=\"HIGHLIGHT_NON_ACTIVE_CHANGELIST\" value=\"false\" />\n    <option name=\"LAST_RESOLUTION\" value=\"IGNORE\" />\n  </component>\n  <component name=\"FileTemplateManagerImpl\">\n    <option name=\"RECENT_TEMPLATES\">\n      <list>\n        <option value=\"Class\" />\n      </list>\n    </option>\n  </component>\n  <component name=\"Git.Settings\">\n    <option name=\"RECENT_BRANCH_BY_REPOSITORY\">\n      <map>\n        <entry key=\"$PROJECT_DIR$\" value=\"master\" />\n      </map>\n    </option>\n    <option name=\"RECENT_GIT_ROOT_PATH\" value=\"$PROJECT_DIR$\" />\n  </component>\n  <component name=\"GitHubPullRequestSearchHistory\">{\n  &quot;lastFilter&quot;: {\n    &quot;state&quot;: &quot;OPEN&quot;,\n    &quot;assignee&quot;: &quot;qqgjyx&quot;\n  }\n}</component>\n  <component name=\"GithubPullRequestsUISettings\">\n    <option name=\"selectedUrlAndAccountId\">\n      <UrlAndAccount>\n        <option name=\"accountId\" value=\"a02e85f0-c4ee-412b-862d-bb168481b438\" />\n        <option name=\"url\" value=\"https://github.com/qqgjyx/CS201-Final-Project\" />\n      </UrlAndAccount>\n    </option>\n  </component>\n  <component name=\"MarkdownSettingsMigration\">\n    <option name=\"stateVersion\" value=\"1\" />\n  </component>\n  <component name=\"ProjectColorInfo\">{\n  &quot;associatedIndex&quot;: 0\n}</component>\n  <component name=\"ProjectId\" id=\"2ZCl8HqoQ9lCfoJqJxb7uIGFhJ6\" />\n  <component name=\"ProjectLevelVcsManager\" settingsEditedManually=\"true\">\n    <ConfirmationsSetting value=\"2\" id=\"Add\" />\n  </component>\n  <component name=\"ProjectViewState\">\n    <option name=\"hideEmptyMiddlePackages\" value=\"true\" />\n    <option name=\"showLibraryContents\" value=\"true\" />\n  </component>\n  <component name=\"PropertiesComponent\">{\n  &quot;keyToString&quot;: {\n    &quot;RunOnceActivity.OpenProjectViewOnStart&quot;: &quot;true&quot;,\n    &quot;RunOnceActivity.ShowReadmeOnStart&quot;: &quot;true&quot;,\n    &quot;WebServerToolWindowFactoryState&quot;: &quot;false&quot;,\n    &quot;git-widget-placeholder&quot;: &quot;master&quot;,\n    &quot;node.js.detected.package.eslint&quot;: &quot;true&quot;,\n    &quot;node.js.detected.package.tslint&quot;: &quot;true&quot;,\n    &quot;node.js.selected.package.eslint&quot;: &quot;(autodetect)&quot;,\n    &quot;node.js.selected.package.tslint&quot;: &quot;(autodetect)&quot;,\n    &quot;nodejs_package_manager_path&quot;: &quot;npm&quot;,\n    &quot;onboarding.tips.debug.path&quot;: &quot;/Users/juntangwang/IdeaProjects/CS201 Final Project/src/Main.java&quot;,\n    &quot;settings.editor.selected.configurable&quot;: &quot;vcs.Git&quot;,\n    &quot;vue.rearranger.settings.migration&quot;: &quot;true&quot;\n  }\n}</component>\n  <component name=\"RecentsManager\">\n    <key name=\"MoveFile.RECENT_KEYS\">\n      <recent name=\"$PROJECT_DIR$/resources\" />\n    </key>\n  </component>\n  <component name=\"SpellCheckerSettings\" RuntimeDictionaries=\"0\" Folders=\"0\" CustomDictionaries=\"0\" DefaultDictionary=\"application-level\" UseSingleDictionary=\"true\" transferred=\"true\" />\n  <component name=\"TaskManager\">\n    <task active=\"true\" id=\"Default\" summary=\"Default task\">\n      <changelist id=\"be025498-9dd4-47fa-9e32-ac2e4e208a37\" name=\"Changes\" comment=\"\" />\n      <created>1701933783896</created>\n      <option name=\"number\" value=\"Default\" />\n      <option name=\"presentableId\" value=\"Default\" />\n      <updated>1701933783896</updated>\n      <workItem from=\"1701933784908\" duration=\"1233000\" />\n      <workItem from=\"1701935157935\" duration=\"6220000\" />\n      <workItem from=\"1701965050681\" duration=\"869000\" />\n      <workItem from=\"1702045779215\" duration=\"4000\" />\n      <workItem from=\"1702045819817\" duration=\"1405000\" />\n    </task>\n    <task id=\"LOCAL-00001\" summary=\"Created roots files\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1701934488962</created>\n      <option name=\"number\" value=\"00001\" />\n      <option name=\"presentableId\" value=\"LOCAL-00001\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1701934488962</updated>\n    </task>\n    <task id=\"LOCAL-00002\" summary=\"Created roots files\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1701934646636</created>\n      <option name=\"number\" value=\"00002\" />\n      <option name=\"presentableId\" value=\"LOCAL-00002\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1701934646636</updated>\n    </task>\n    <task id=\"LOCAL-00003\" summary=\"Frameworks setted\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1701936611398</created>\n      <option name=\"number\" value=\"00003\" />\n      <option name=\"presentableId\" value=\"LOCAL-00003\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1701936611398</updated>\n    </task>\n    <task id=\"LOCAL-00004\" summary=\"v0.9.1 workable-not tested\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1701940431694</created>\n      <option name=\"number\" value=\"00004\" />\n      <option name=\"presentableId\" value=\"LOCAL-00004\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1701940431694</updated>\n    </task>\n    <task id=\"LOCAL-00005\" summary=\"v0.9.1 workable-not tested\">\n      <option name=\"closed\" value=\"true\" />\n      <created>1701940755476</created>\n      <option name=\"number\" value=\"00005\" />\n      <option name=\"presentableId\" value=\"LOCAL-00005\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1701940755476</updated>\n    </task>\n    <option name=\"localTasksCounter\" value=\"6\" />\n    <servers />\n  </component>\n  <component name=\"TypeScriptGeneratedFilesManager\">\n    <option name=\"version\" value=\"3\" />\n  </component>\n  <component name=\"Vcs.Log.Tabs.Properties\">\n    <option name=\"TAB_STATES\">\n      <map>\n        <entry key=\"MAIN\">\n          <value>\n            <State>\n              <option name=\"FILTERS\">\n                <map>\n                  <entry key=\"branch\">\n                    <value>\n                      <list>\n                        <option value=\"origin/master\" />\n                      </list>\n                    </value>\n                  </entry>\n                </map>\n              </option>\n            </State>\n          </value>\n        </entry>\n      </map>\n    </option>\n  </component>\n  <component name=\"VcsManagerConfiguration\">\n    <MESSAGE value=\"Created roots files\" />\n    <MESSAGE value=\"Frameworks setted\" />\n    <MESSAGE value=\"v0.9.1 workable-not tested\" />\n    <option name=\"LAST_COMMIT_MESSAGE\" value=\"v0.9.1 workable-not tested\" />\n  </component>\n  <component name=\"XSLT-Support.FileAssociations.UIState\">\n    <expand />\n    <select />\n  </component>\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/workspace.xml b/.idea/workspace.xml
--- a/.idea/workspace.xml	(revision 913c7a88f881367f958969be0cd7f61701a1ca93)
+++ b/.idea/workspace.xml	(date 1702185139115)
@@ -4,9 +4,8 @@
     <option name="autoReloadType" value="SELECTIVE" />
   </component>
   <component name="ChangeListManager">
-    <list default="true" id="be025498-9dd4-47fa-9e32-ac2e4e208a37" name="Changes" comment="v0.9.1 workable-not tested">
+    <list default="true" id="be025498-9dd4-47fa-9e32-ac2e4e208a37" name="Changes" comment="v0.9.2 workable-not tested">
       <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/resources/DatabaseProcessing.java" beforeDir="false" />
       <change beforePath="$PROJECT_DIR$/src/DatabaseProcessing.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/DatabaseProcessing.java" afterDir="false" />
     </list>
     <option name="SHOW_DIALOG" value="false" />
@@ -62,7 +61,7 @@
     &quot;RunOnceActivity.OpenProjectViewOnStart&quot;: &quot;true&quot;,
     &quot;RunOnceActivity.ShowReadmeOnStart&quot;: &quot;true&quot;,
     &quot;WebServerToolWindowFactoryState&quot;: &quot;false&quot;,
-    &quot;git-widget-placeholder&quot;: &quot;master&quot;,
+    &quot;git-widget-placeholder&quot;: &quot;Cherry-picking in master&quot;,
     &quot;node.js.detected.package.eslint&quot;: &quot;true&quot;,
     &quot;node.js.detected.package.tslint&quot;: &quot;true&quot;,
     &quot;node.js.selected.package.eslint&quot;: &quot;(autodetect)&quot;,
@@ -75,6 +74,7 @@
 }</component>
   <component name="RecentsManager">
     <key name="MoveFile.RECENT_KEYS">
+      <recent name="$PROJECT_DIR$/src" />
       <recent name="$PROJECT_DIR$/resources" />
     </key>
   </component>
@@ -90,7 +90,8 @@
       <workItem from="1701935157935" duration="6220000" />
       <workItem from="1701965050681" duration="869000" />
       <workItem from="1702045779215" duration="4000" />
-      <workItem from="1702045819817" duration="1405000" />
+      <workItem from="1702045819817" duration="2511000" />
+      <workItem from="1702100223450" duration="1610000" />
     </task>
     <task id="LOCAL-00001" summary="Created roots files">
       <option name="closed" value="true" />
@@ -132,7 +133,15 @@
       <option name="project" value="LOCAL" />
       <updated>1701940755476</updated>
     </task>
-    <option name="localTasksCounter" value="6" />
+    <task id="LOCAL-00006" summary="v0.9.2 workable-not tested">
+      <option name="closed" value="true" />
+      <created>1702047455956</created>
+      <option name="number" value="00006" />
+      <option name="presentableId" value="LOCAL-00006" />
+      <option name="project" value="LOCAL" />
+      <updated>1702047455956</updated>
+    </task>
+    <option name="localTasksCounter" value="7" />
     <servers />
   </component>
   <component name="TypeScriptGeneratedFilesManager">
@@ -149,7 +158,7 @@
                   <entry key="branch">
                     <value>
                       <list>
-                        <option value="origin/master" />
+                        <option value="master" />
                       </list>
                     </value>
                   </entry>
@@ -165,7 +174,8 @@
     <MESSAGE value="Created roots files" />
     <MESSAGE value="Frameworks setted" />
     <MESSAGE value="v0.9.1 workable-not tested" />
-    <option name="LAST_COMMIT_MESSAGE" value="v0.9.1 workable-not tested" />
+    <MESSAGE value="v0.9.2 workable-not tested" />
+    <option name="LAST_COMMIT_MESSAGE" value="v0.9.2 workable-not tested" />
   </component>
   <component name="XSLT-Support.FileAssociations.UIState">
     <expand />
